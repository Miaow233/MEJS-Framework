class java.lang.StringBuffer extends java.lang.AbstractStringBuilder {
// Constructors
public constructor() {
return new Packages.java.lang.StringBuffer()
}
// Constructors
public constructor(int: number) {
return new Packages.java.lang.StringBuffer(int)
}
// Constructors
public constructor(cha: CharSequence) {
return new Packages.java.lang.StringBuffer(cha)
}
// Constructors
public constructor(str: string) {
return new Packages.java.lang.StringBuffer(str)
}
// Methods
private readObject(obj: ObjectInputStream): void {
this.readObject(obj)
}
private synchronized writeObject(obj: ObjectOutputStream): void {
this.writeObject(obj)
}
public volatile append(cha: char): AbstractStringBuilder {
return this.append(cha)
}
public volatile append(dou: double): AbstractStringBuilder {
return this.append(dou)
}
public volatile append(flo: float): AbstractStringBuilder {
return this.append(flo)
}
public volatile append(int: number): AbstractStringBuilder {
return this.append(int)
}
public volatile append(lon: number): AbstractStringBuilder {
return this.append(lon)
}
public volatile append(cha: CharSequence): AbstractStringBuilder {
return this.append(cha)
}
public volatile append(cha: CharSequence, int: number, int_1: number): AbstractStringBuilder {
return this.append(cha, int, int_1)
}
public volatile append(obj: Object): AbstractStringBuilder {
return this.append(obj)
}
public volatile append(str: string): AbstractStringBuilder {
return this.append(str)
}
public volatile append(str: StringBuffer): AbstractStringBuilder {
return this.append(str)
}
public volatile append(boo: boolean): AbstractStringBuilder {
return this.append(boo)
}
public volatile append(c: String[]): AbstractStringBuilder {
return this.append(c)
}
public volatile append(c: String[], int: number, int_1: number): AbstractStringBuilder {
return this.append(c, int, int_1)
}
public volatile append(cha: char): Appendable {
return this.append(cha)
}
public volatile append(cha: CharSequence): Appendable {
return this.append(cha)
}
public volatile append(cha: CharSequence, int: number, int_1: number): Appendable {
return this.append(cha, int, int_1)
}
public synchronized append(cha: char): StringBuffer {
return this.append(cha)
}
public synchronized append(dou: double): StringBuffer {
return this.append(dou)
}
public synchronized append(flo: float): StringBuffer {
return this.append(flo)
}
public synchronized append(int: number): StringBuffer {
return this.append(int)
}
public synchronized append(lon: number): StringBuffer {
return this.append(lon)
}
public append(cha: CharSequence): StringBuffer {
return this.append(cha)
}
public synchronized append(cha: CharSequence, int: number, int_1: number): StringBuffer {
return this.append(cha, int, int_1)
}
public synchronized append(obj: Object): StringBuffer {
return this.append(obj)
}
public synchronized append(str: string): StringBuffer {
return this.append(str)
}
public synchronized append(str: StringBuffer): StringBuffer {
return this.append(str)
}
public synchronized append(boo: boolean): StringBuffer {
return this.append(boo)
}
public synchronized append(c: String[]): StringBuffer {
return this.append(c)
}
public synchronized append(c: String[], int: number, int_1: number): StringBuffer {
return this.append(c, int, int_1)
}
public volatile appendCodePoint(int: number): AbstractStringBuilder {
return this.appendCodePoint(int)
}
public synchronized appendCodePoint(int: number): StringBuffer {
return this.appendCodePoint(int)
}
public synchronized capacity(): number {
return this.capacity()
}
public synchronized charAt(int: number): char {
return this.charAt(int)
}
public synchronized codePointAt(int: number): number {
return this.codePointAt(int)
}
public synchronized codePointBefore(int: number): number {
return this.codePointBefore(int)
}
public synchronized codePointCount(int: number, int_1: number): number {
return this.codePointCount(int, int_1)
}
public volatile delete(int: number, int_1: number): AbstractStringBuilder {
return this.delete(int, int_1)
}
public synchronized delete(int: number, int_1: number): StringBuffer {
return this.delete(int, int_1)
}
public volatile deleteCharAt(int: number): AbstractStringBuilder {
return this.deleteCharAt(int)
}
public synchronized deleteCharAt(int: number): StringBuffer {
return this.deleteCharAt(int)
}
public synchronized ensureCapacity(int: number): void {
this.ensureCapacity(int)
}
public synchronized getChars(int: number, int_1: number, c: String[], int_2: number): void {
this.getChars(int, int_1, c, int_2)
}
public indexOf(str: string): number {
return this.indexOf(str)
}
public synchronized indexOf(str: string, int: number): number {
return this.indexOf(str, int)
}
public volatile insert(int: number, cha: char): AbstractStringBuilder {
return this.insert(int, cha)
}
public volatile insert(int: number, dou: double): AbstractStringBuilder {
return this.insert(int, dou)
}
public volatile insert(int: number, flo: float): AbstractStringBuilder {
return this.insert(int, flo)
}
public volatile insert(int: number, int_1: number): AbstractStringBuilder {
return this.insert(int, int_1)
}
public volatile insert(int: number, lon: number): AbstractStringBuilder {
return this.insert(int, lon)
}
public volatile insert(int: number, cha: CharSequence): AbstractStringBuilder {
return this.insert(int, cha)
}
public volatile insert(int: number, cha: CharSequence, int_1: number, int_2: number): AbstractStringBuilder {
return this.insert(int, cha, int_1, int_2)
}
public volatile insert(int: number, obj: Object): AbstractStringBuilder {
return this.insert(int, obj)
}
public volatile insert(int: number, str: string): AbstractStringBuilder {
return this.insert(int, str)
}
public volatile insert(int: number, boo: boolean): AbstractStringBuilder {
return this.insert(int, boo)
}
public volatile insert(int: number, c: String[]): AbstractStringBuilder {
return this.insert(int, c)
}
public volatile insert(int: number, c: String[], int_1: number, int_2: number): AbstractStringBuilder {
return this.insert(int, c, int_1, int_2)
}
public synchronized insert(int: number, cha: char): StringBuffer {
return this.insert(int, cha)
}
public insert(int: number, dou: double): StringBuffer {
return this.insert(int, dou)
}
public insert(int: number, flo: float): StringBuffer {
return this.insert(int, flo)
}
public insert(int: number, int_1: number): StringBuffer {
return this.insert(int, int_1)
}
public insert(int: number, lon: number): StringBuffer {
return this.insert(int, lon)
}
public insert(int: number, cha: CharSequence): StringBuffer {
return this.insert(int, cha)
}
public synchronized insert(int: number, cha: CharSequence, int_1: number, int_2: number): StringBuffer {
return this.insert(int, cha, int_1, int_2)
}
public synchronized insert(int: number, obj: Object): StringBuffer {
return this.insert(int, obj)
}
public synchronized insert(int: number, str: string): StringBuffer {
return this.insert(int, str)
}
public insert(int: number, boo: boolean): StringBuffer {
return this.insert(int, boo)
}
public synchronized insert(int: number, c: String[]): StringBuffer {
return this.insert(int, c)
}
public synchronized insert(int: number, c: String[], int_1: number, int_2: number): StringBuffer {
return this.insert(int, c, int_1, int_2)
}
public lastIndexOf(str: string): number {
return this.lastIndexOf(str)
}
public synchronized lastIndexOf(str: string, int: number): number {
return this.lastIndexOf(str, int)
}
public synchronized length(): number {
return this.length()
}
public synchronized offsetByCodePoints(int: number, int_1: number): number {
return this.offsetByCodePoints(int, int_1)
}
public volatile replace(int: number, int_1: number, str: string): AbstractStringBuilder {
return this.replace(int, int_1, str)
}
public synchronized replace(int: number, int_1: number, str: string): StringBuffer {
return this.replace(int, int_1, str)
}
public volatile reverse(): AbstractStringBuilder {
return this.reverse()
}
public synchronized reverse(): StringBuffer {
return this.reverse()
}
public synchronized setCharAt(int: number, cha: char): void {
this.setCharAt(int, cha)
}
public synchronized setLength(int: number): void {
this.setLength(int)
}
public synchronized subSequence(int: number, int_1: number): CharSequence {
return this.subSequence(int, int_1)
}
public synchronized substring(int: number): string {
return this.substring(int)
}
public synchronized substring(int: number, int_1: number): string {
return this.substring(int, int_1)
}
public synchronized toString(): string {
return this.toString()
}
public synchronized trimToSize(): void {
this.trimToSize()
}
// Fields
private static serialPersistentFields: ObjectStreamField[]
static serialVersionUID: number
}